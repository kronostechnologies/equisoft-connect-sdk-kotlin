/**
* Equisoft /connect API
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: latest
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package equisoft/openapi.apis

import equisoft/openapi.models.ErrorResponse
import equisoft/openapi.models.InternalNotesCreateNotePayload
import equisoft/openapi.models.InternalNotesCreateNoteResponse
import equisoft/openapi.models.InternalNotesHistoryType
import equisoft/openapi.models.InternalNotesNoteList
import equisoft/openapi.models.InternalNotesPatchNotePayload
import equisoft/openapi.models.InternalNotesPatchNoteResponse
import equisoft/openapi.models.TasksCreateTaskPayload
import equisoft/openapi.models.TasksCreateTaskResponse
import equisoft/openapi.models.TasksDueDateFilter
import equisoft/openapi.models.TasksListTaskResponse
import equisoft/openapi.models.TasksOrderByType
import equisoft/openapi.models.TasksPatchTaskPayload
import equisoft/openapi.models.TasksPatchTaskResponse
import equisoft/openapi.models.TasksTask
import equisoft/openapi.models.TasksTransferToCompletedResponse

import equisoft/openapi.infrastructure.ApiClient
import equisoft/openapi.infrastructure.ClientException
import equisoft/openapi.infrastructure.ClientError
import equisoft/openapi.infrastructure.ServerException
import equisoft/openapi.infrastructure.ServerError
import equisoft/openapi.infrastructure.MultiValueMap
import equisoft/openapi.infrastructure.RequestConfig
import equisoft/openapi.infrastructure.RequestMethod
import equisoft/openapi.infrastructure.ResponseType
import equisoft/openapi.infrastructure.Success
import equisoft/openapi.infrastructure.toMultiValue

class TasksApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("equisoft/openapi.baseUrl", "http://localhost")
        }
    }

    /**
    * Archive an internal note for a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun archiveTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : kotlin.Any {
        val localVariableConfig = archiveTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation archiveTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun archiveTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}/archive".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Create a task.
    * 
    * @param tasksCreateTaskPayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksCreateTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTask(tasksCreateTaskPayload: TasksCreateTaskPayload, acceptLanguage: kotlin.String?) : TasksCreateTaskResponse {
        val localVariableConfig = createTaskRequestConfig(tasksCreateTaskPayload = tasksCreateTaskPayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksCreateTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksCreateTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTask
    *
    * @param tasksCreateTaskPayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun createTaskRequestConfig(tasksCreateTaskPayload: TasksCreateTaskPayload, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tasksCreateTaskPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Add an internal note to a task.
    * 
    * @param taskId Task unique identifier. 
    * @param internalNotesCreateNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesCreateNoteResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTaskInternalNote(taskId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : InternalNotesCreateNoteResponse {
        val localVariableConfig = createTaskInternalNoteRequestConfig(taskId = taskId, internalNotesCreateNotePayload = internalNotesCreateNotePayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<InternalNotesCreateNoteResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesCreateNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param internalNotesCreateNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun createTaskInternalNoteRequestConfig(taskId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = internalNotesCreateNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Delete a task.
    * 
    * @param taskId  
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTask(taskId: kotlin.String) : kotlin.Any {
        val localVariableConfig = deleteTaskRequestConfig(taskId = taskId)

        val localVarResponse = request<kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteTask
    *
    * @param taskId  
    * @return RequestConfig
    */
    fun deleteTaskRequestConfig(taskId: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.DELETE,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Return the detail of a task.
    * 
    * @param taskId  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksTask
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTask(taskId: kotlin.String, acceptLanguage: kotlin.String?) : TasksTask {
        val localVariableConfig = getTaskRequestConfig(taskId = taskId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksTask>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksTask
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTask
    *
    * @param taskId  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun getTaskRequestConfig(taskId: kotlin.String, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Get the internal notes list for a task.
    * 
    * @param taskId  
    * @param history Query all revisions or not. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesNoteList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTaskInternalNoteList(taskId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : InternalNotesNoteList {
        val localVariableConfig = getTaskInternalNoteListRequestConfig(taskId = taskId, history = history, acceptLanguage = acceptLanguage)

        val localVarResponse = request<InternalNotesNoteList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesNoteList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTaskInternalNoteList
    *
    * @param taskId  
    * @param history Query all revisions or not. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun getTaskInternalNoteListRequestConfig(taskId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (history != null) {
                    put("history", listOf(history.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks/{taskId}/notes".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * List or search tasks.
    * 
    * @param ownerId Owner ID filter param. (optional)
    * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
    * @param minDueDate Minimum (inclusive) due date of the task. (optional)
    * @param maxDueDate Maximum (exclusive) due date of the task. (optional)
    * @param isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
    * @param dueDateFilter Include or exclude tasks with or without due date. (optional)
    * @param orderBy Specify the order of the results. (optional)
    * @param pageToken Token to specify which page to fetch. (optional)
    * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksListTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTasks(ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minDueDate: java.time.LocalDate?, maxDueDate: java.time.LocalDate?, isCompleted: kotlin.Boolean?, dueDateFilter: TasksDueDateFilter?, orderBy: TasksOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : TasksListTaskResponse {
        val localVariableConfig = listTasksRequestConfig(ownerId = ownerId, contactIds = contactIds, minDueDate = minDueDate, maxDueDate = maxDueDate, isCompleted = isCompleted, dueDateFilter = dueDateFilter, orderBy = orderBy, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksListTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksListTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTasks
    *
    * @param ownerId Owner ID filter param. (optional)
    * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
    * @param minDueDate Minimum (inclusive) due date of the task. (optional)
    * @param maxDueDate Maximum (exclusive) due date of the task. (optional)
    * @param isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
    * @param dueDateFilter Include or exclude tasks with or without due date. (optional)
    * @param orderBy Specify the order of the results. (optional)
    * @param pageToken Token to specify which page to fetch. (optional)
    * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun listTasksRequestConfig(ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minDueDate: java.time.LocalDate?, maxDueDate: java.time.LocalDate?, isCompleted: kotlin.Boolean?, dueDateFilter: TasksDueDateFilter?, orderBy: TasksOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (ownerId != null) {
                    put("ownerId", listOf(ownerId.toString()))
                }
                if (contactIds != null) {
                    put("contactIds", toMultiValue(contactIds.toList(), "multi"))
                }
                if (minDueDate != null) {
                    put("minDueDate", listOf(parseDateToQueryString(minDueDate)))
                }
                if (maxDueDate != null) {
                    put("maxDueDate", listOf(parseDateToQueryString(maxDueDate)))
                }
                if (isCompleted != null) {
                    put("isCompleted", listOf(isCompleted.toString()))
                }
                if (dueDateFilter != null) {
                    put("dueDateFilter", listOf(dueDateFilter.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (pageToken != null) {
                    put("pageToken", listOf(pageToken.toString()))
                }
                if (maxResults != null) {
                    put("maxResults", listOf(maxResults.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Partially update a task.
    * 
    * @param taskId Task unique identifier. 
    * @param tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksPatchTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchTask(taskId: kotlin.String, tasksPatchTaskPayload: TasksPatchTaskPayload, acceptLanguage: kotlin.String?) : TasksPatchTaskResponse {
        val localVariableConfig = patchTaskRequestConfig(taskId = taskId, tasksPatchTaskPayload = tasksPatchTaskPayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksPatchTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksPatchTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation patchTask
    *
    * @param taskId Task unique identifier. 
    * @param tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun patchTaskRequestConfig(taskId: kotlin.String, tasksPatchTaskPayload: TasksPatchTaskPayload, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = tasksPatchTaskPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Add an internal note to a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param internalNotesPatchNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesPatchNoteResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : InternalNotesPatchNoteResponse {
        val localVariableConfig = patchTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, internalNotesPatchNotePayload = internalNotesPatchNotePayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<InternalNotesPatchNoteResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesPatchNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation patchTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param internalNotesPatchNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun patchTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = internalNotesPatchNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Restore an archived internal note for a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : kotlin.Any {
        val localVariableConfig = restoreTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation restoreTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun restoreTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}/restore".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * Transfer a task to completed/done.
    * 
    * @param taskId Task unique identifier. 
    * @return TasksTransferToCompletedResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun transferTaskToCompleted(taskId: kotlin.String) : TasksTransferToCompletedResponse {
        val localVariableConfig = transferTaskToCompletedRequestConfig(taskId = taskId)

        val localVarResponse = request<TasksTransferToCompletedResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksTransferToCompletedResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation transferTaskToCompleted
    *
    * @param taskId Task unique identifier. 
    * @return RequestConfig
    */
    fun transferTaskToCompletedRequestConfig(taskId: kotlin.String) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/transferToCompleted".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
