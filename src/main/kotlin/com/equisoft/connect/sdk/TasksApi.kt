/**
 * Equisoft /connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.equisoft.connect.sdk

import com.equisoft.connect.sdk.models.ErrorResponse
import com.equisoft.connect.sdk.models.InternalNotesCreateNotePayload
import com.equisoft.connect.sdk.models.InternalNotesCreateNoteResponse
import com.equisoft.connect.sdk.models.InternalNotesHistoryType
import com.equisoft.connect.sdk.models.InternalNotesNoteList
import com.equisoft.connect.sdk.models.InternalNotesPatchNotePayload
import com.equisoft.connect.sdk.models.InternalNotesPatchNoteResponse
import com.equisoft.connect.sdk.models.TasksCreateTaskPayload
import com.equisoft.connect.sdk.models.TasksCreateTaskResponse
import com.equisoft.connect.sdk.models.TasksDueDateFilter
import com.equisoft.connect.sdk.models.TasksListTaskResponse
import com.equisoft.connect.sdk.models.TasksOrderByType
import com.equisoft.connect.sdk.models.TasksPatchTaskPayload
import com.equisoft.connect.sdk.models.TasksPatchTaskResponse
import com.equisoft.connect.sdk.models.TasksTask
import com.equisoft.connect.sdk.models.TasksTransferToCompletedResponse

import com.equisoft.connect.sdk.infrastructure.ApiClient
import com.equisoft.connect.sdk.infrastructure.ClientException
import com.equisoft.connect.sdk.infrastructure.ClientError
import com.equisoft.connect.sdk.infrastructure.ServerException
import com.equisoft.connect.sdk.infrastructure.ServerError
import com.equisoft.connect.sdk.infrastructure.MultiValueMap
import com.equisoft.connect.sdk.infrastructure.RequestConfig
import com.equisoft.connect.sdk.infrastructure.RequestMethod
import com.equisoft.connect.sdk.infrastructure.ResponseType
import com.equisoft.connect.sdk.infrastructure.Success
import com.equisoft.connect.sdk.infrastructure.toMultiValue

class TasksApi(
    basePath: kotlin.String = defaultBasePath,
    accessToken: String? = null
) : ApiClient(basePath, accessToken) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("com.equisoft.connect.sdk.baseUrl", "http://localhost")
        }
    }

    /**
    * Archive an internal note for a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun archiveTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : kotlin.Any {
        val localVariableConfig = archiveTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<Unit, kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation archiveTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun archiveTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}/archive".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a task.
    * 
    * @param tasksCreateTaskPayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksCreateTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTask(tasksCreateTaskPayload: TasksCreateTaskPayload, acceptLanguage: kotlin.String?) : TasksCreateTaskResponse {
        val localVariableConfig = createTaskRequestConfig(tasksCreateTaskPayload = tasksCreateTaskPayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksCreateTaskPayload, TasksCreateTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksCreateTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTask
    *
    * @param tasksCreateTaskPayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun createTaskRequestConfig(tasksCreateTaskPayload: TasksCreateTaskPayload, acceptLanguage: kotlin.String?) : RequestConfig<TasksCreateTaskPayload> {
        val localVariableBody = tasksCreateTaskPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Add an internal note to a task.
    * 
    * @param taskId Task unique identifier. 
    * @param internalNotesCreateNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesCreateNoteResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTaskInternalNote(taskId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : InternalNotesCreateNoteResponse {
        val localVariableConfig = createTaskInternalNoteRequestConfig(taskId = taskId, internalNotesCreateNotePayload = internalNotesCreateNotePayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<InternalNotesCreateNotePayload, InternalNotesCreateNoteResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesCreateNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation createTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param internalNotesCreateNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun createTaskInternalNoteRequestConfig(taskId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : RequestConfig<InternalNotesCreateNotePayload> {
        val localVariableBody = internalNotesCreateNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete a task.
    * 
    * @param taskId  
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTask(taskId: kotlin.String) : kotlin.Any {
        val localVariableConfig = deleteTaskRequestConfig(taskId = taskId)

        val localVarResponse = request<Unit, kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deleteTask
    *
    * @param taskId  
    * @return RequestConfig
    */
    fun deleteTaskRequestConfig(taskId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Return the detail of a task.
    * 
    * @param taskId  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksTask
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTask(taskId: kotlin.String, acceptLanguage: kotlin.String?) : TasksTask {
        val localVariableConfig = getTaskRequestConfig(taskId = taskId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<Unit, TasksTask>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksTask
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTask
    *
    * @param taskId  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun getTaskRequestConfig(taskId: kotlin.String, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get the internal notes list for a task.
    * 
    * @param taskId  
    * @param history Query all revisions or not. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesNoteList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTaskInternalNoteList(taskId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : InternalNotesNoteList {
        val localVariableConfig = getTaskInternalNoteListRequestConfig(taskId = taskId, history = history, acceptLanguage = acceptLanguage)

        val localVarResponse = request<Unit, InternalNotesNoteList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesNoteList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation getTaskInternalNoteList
    *
    * @param taskId  
    * @param history Query all revisions or not. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun getTaskInternalNoteListRequestConfig(taskId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (history != null) {
                    put("history", listOf(history.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks/{taskId}/notes".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List or search tasks.
    * 
    * @param ownerId Owner ID filter param. (optional)
    * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
    * @param minDueDate Minimum (inclusive) due date of the task. (optional)
    * @param maxDueDate Maximum (exclusive) due date of the task. (optional)
    * @param isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
    * @param dueDateFilter Include or exclude tasks with or without due date. (optional)
    * @param orderBy Specify the order of the results. (optional)
    * @param pageToken Token to specify which page to fetch. (optional)
    * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksListTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTasks(ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minDueDate: java.time.LocalDate?, maxDueDate: java.time.LocalDate?, isCompleted: kotlin.Boolean?, dueDateFilter: TasksDueDateFilter?, orderBy: TasksOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : TasksListTaskResponse {
        val localVariableConfig = listTasksRequestConfig(ownerId = ownerId, contactIds = contactIds, minDueDate = minDueDate, maxDueDate = maxDueDate, isCompleted = isCompleted, dueDateFilter = dueDateFilter, orderBy = orderBy, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        val localVarResponse = request<Unit, TasksListTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksListTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation listTasks
    *
    * @param ownerId Owner ID filter param. (optional)
    * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
    * @param minDueDate Minimum (inclusive) due date of the task. (optional)
    * @param maxDueDate Maximum (exclusive) due date of the task. (optional)
    * @param isCompleted If true, include only completed tasks. If false, include only TODO tasks. If not set or null, include both. (optional)
    * @param dueDateFilter Include or exclude tasks with or without due date. (optional)
    * @param orderBy Specify the order of the results. (optional)
    * @param pageToken Token to specify which page to fetch. (optional)
    * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun listTasksRequestConfig(ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minDueDate: java.time.LocalDate?, maxDueDate: java.time.LocalDate?, isCompleted: kotlin.Boolean?, dueDateFilter: TasksDueDateFilter?, orderBy: TasksOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (ownerId != null) {
                    put("ownerId", listOf(ownerId.toString()))
                }
                if (contactIds != null) {
                    put("contactIds", toMultiValue(contactIds.toList(), "multi"))
                }
                if (minDueDate != null) {
                    put("minDueDate", listOf(parseDateToQueryString(minDueDate)))
                }
                if (maxDueDate != null) {
                    put("maxDueDate", listOf(parseDateToQueryString(maxDueDate)))
                }
                if (isCompleted != null) {
                    put("isCompleted", listOf(isCompleted.toString()))
                }
                if (dueDateFilter != null) {
                    put("dueDateFilter", listOf(dueDateFilter.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (pageToken != null) {
                    put("pageToken", listOf(pageToken.toString()))
                }
                if (maxResults != null) {
                    put("maxResults", listOf(maxResults.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Partially update a task.
    * 
    * @param taskId Task unique identifier. 
    * @param tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return TasksPatchTaskResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchTask(taskId: kotlin.String, tasksPatchTaskPayload: TasksPatchTaskPayload, acceptLanguage: kotlin.String?) : TasksPatchTaskResponse {
        val localVariableConfig = patchTaskRequestConfig(taskId = taskId, tasksPatchTaskPayload = tasksPatchTaskPayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<TasksPatchTaskPayload, TasksPatchTaskResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksPatchTaskResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation patchTask
    *
    * @param taskId Task unique identifier. 
    * @param tasksPatchTaskPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun patchTaskRequestConfig(taskId: kotlin.String, tasksPatchTaskPayload: TasksPatchTaskPayload, acceptLanguage: kotlin.String?) : RequestConfig<TasksPatchTaskPayload> {
        val localVariableBody = tasksPatchTaskPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/tasks/{taskId}".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Add an internal note to a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param internalNotesPatchNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return InternalNotesPatchNoteResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : InternalNotesPatchNoteResponse {
        val localVariableConfig = patchTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, internalNotesPatchNotePayload = internalNotesPatchNotePayload, acceptLanguage = acceptLanguage)

        val localVarResponse = request<InternalNotesPatchNotePayload, InternalNotesPatchNoteResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesPatchNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation patchTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param internalNotesPatchNotePayload  
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun patchTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : RequestConfig<InternalNotesPatchNotePayload> {
        val localVariableBody = internalNotesPatchNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Restore an archived internal note for a task.
    * 
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return kotlin.Any
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreTaskInternalNote(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : kotlin.Any {
        val localVariableConfig = restoreTaskInternalNoteRequestConfig(taskId = taskId, noteId = noteId, acceptLanguage = acceptLanguage)

        val localVarResponse = request<Unit, kotlin.Any>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation restoreTaskInternalNote
    *
    * @param taskId Task unique identifier. 
    * @param noteId Note unique identifier. 
    * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
    * @return RequestConfig
    */
    fun restoreTaskInternalNoteRequestConfig(taskId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/notes/{noteId}/restore".replace("{"+"taskId"+"}", "$taskId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Transfer a task to completed/done.
    * 
    * @param taskId Task unique identifier. 
    * @return TasksTransferToCompletedResponse
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun transferTaskToCompleted(taskId: kotlin.String) : TasksTransferToCompletedResponse {
        val localVariableConfig = transferTaskToCompletedRequestConfig(taskId = taskId)

        val localVarResponse = request<Unit, TasksTransferToCompletedResponse>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TasksTransferToCompletedResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation transferTaskToCompleted
    *
    * @param taskId Task unique identifier. 
    * @return RequestConfig
    */
    fun transferTaskToCompletedRequestConfig(taskId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/tasks/{taskId}/transferToCompleted".replace("{"+"taskId"+"}", "$taskId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
