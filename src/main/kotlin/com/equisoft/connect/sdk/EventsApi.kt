/**
 * Equisoft /connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.equisoft.connect.sdk

import java.io.IOException
import okhttp3.OkHttpClient

import com.equisoft.connect.sdk.models.CalendarsCalendar
import com.equisoft.connect.sdk.models.CalendarsListCalendarResponse
import com.equisoft.connect.sdk.models.ErrorResponse
import com.equisoft.connect.sdk.models.EventsCreateEventPayload
import com.equisoft.connect.sdk.models.EventsCreateEventResponse
import com.equisoft.connect.sdk.models.EventsEvent
import com.equisoft.connect.sdk.models.EventsGetEventInstancesResponse
import com.equisoft.connect.sdk.models.EventsListEventResponse
import com.equisoft.connect.sdk.models.EventsOrderByType
import com.equisoft.connect.sdk.models.EventsPatchEventPayload
import com.equisoft.connect.sdk.models.EventsPatchEventResponse
import com.equisoft.connect.sdk.models.EventsTransferToCompletedResponse
import com.equisoft.connect.sdk.models.InternalNotesCreateNotePayload
import com.equisoft.connect.sdk.models.InternalNotesCreateNoteResponse
import com.equisoft.connect.sdk.models.InternalNotesHistoryType
import com.equisoft.connect.sdk.models.InternalNotesNoteList
import com.equisoft.connect.sdk.models.InternalNotesPatchNotePayload
import com.equisoft.connect.sdk.models.InternalNotesPatchNoteResponse

import com.squareup.moshi.Json

import com.equisoft.connect.sdk.infrastructure.ApiClient
import com.equisoft.connect.sdk.infrastructure.ApiResponse
import com.equisoft.connect.sdk.infrastructure.ClientException
import com.equisoft.connect.sdk.infrastructure.ClientError
import com.equisoft.connect.sdk.infrastructure.ServerException
import com.equisoft.connect.sdk.infrastructure.ServerError
import com.equisoft.connect.sdk.infrastructure.MultiValueMap
import com.equisoft.connect.sdk.infrastructure.PartConfig
import com.equisoft.connect.sdk.infrastructure.RequestConfig
import com.equisoft.connect.sdk.infrastructure.RequestMethod
import com.equisoft.connect.sdk.infrastructure.ResponseType
import com.equisoft.connect.sdk.infrastructure.Success
import com.equisoft.connect.sdk.infrastructure.toMultiValue

class EventsApi(
    basePath: kotlin.String = defaultBasePath,
    accessToken: String? = null,
    client: OkHttpClient = ApiClient.defaultClient
) : ApiClient(basePath, accessToken) {

    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Archive an internal note for and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun archiveEventInternalNote(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String? = null) : kotlin.Any {
        val localVarResponse = archiveEventInternalNoteWithHttpInfo(eventId = eventId, noteId = noteId, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Archive an internal note for and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun archiveEventInternalNoteWithHttpInfo(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = archiveEventInternalNoteRequestConfig(eventId = eventId, noteId = noteId, acceptLanguage = acceptLanguage)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation archiveEventInternalNote
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun archiveEventInternalNoteRequestConfig(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/events/{eventId}/notes/{noteId}/archive".replace("{"+"eventId"+"}", "$eventId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create an event.
     * 
     * @param eventsCreateEventPayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return EventsCreateEventResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEvent(eventsCreateEventPayload: EventsCreateEventPayload, acceptLanguage: kotlin.String? = null) : EventsCreateEventResponse {
        val localVarResponse = createEventWithHttpInfo(eventsCreateEventPayload = eventsCreateEventPayload, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsCreateEventResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create an event.
     * 
     * @param eventsCreateEventPayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<EventsCreateEventResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEventWithHttpInfo(eventsCreateEventPayload: EventsCreateEventPayload, acceptLanguage: kotlin.String?) : ApiResponse<EventsCreateEventResponse?> {
        val localVariableConfig = createEventRequestConfig(eventsCreateEventPayload = eventsCreateEventPayload, acceptLanguage = acceptLanguage)

        return request<EventsCreateEventPayload, EventsCreateEventResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEvent
     *
     * @param eventsCreateEventPayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun createEventRequestConfig(eventsCreateEventPayload: EventsCreateEventPayload, acceptLanguage: kotlin.String?) : RequestConfig<EventsCreateEventPayload> {
        val localVariableBody = eventsCreateEventPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add an internal note to and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param internalNotesCreateNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return InternalNotesCreateNoteResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createEventInternalNote(eventId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String? = null) : InternalNotesCreateNoteResponse {
        val localVarResponse = createEventInternalNoteWithHttpInfo(eventId = eventId, internalNotesCreateNotePayload = internalNotesCreateNotePayload, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesCreateNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add an internal note to and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param internalNotesCreateNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<InternalNotesCreateNoteResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createEventInternalNoteWithHttpInfo(eventId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : ApiResponse<InternalNotesCreateNoteResponse?> {
        val localVariableConfig = createEventInternalNoteRequestConfig(eventId = eventId, internalNotesCreateNotePayload = internalNotesCreateNotePayload, acceptLanguage = acceptLanguage)

        return request<InternalNotesCreateNotePayload, InternalNotesCreateNoteResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createEventInternalNote
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param internalNotesCreateNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun createEventInternalNoteRequestConfig(eventId: kotlin.String, internalNotesCreateNotePayload: InternalNotesCreateNotePayload, acceptLanguage: kotlin.String?) : RequestConfig<InternalNotesCreateNotePayload> {
        val localVariableBody = internalNotesCreateNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/events/{eventId}/notes".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete an event.
     * **Note:** To delete an instance of recurring event, use the master event id suffixed by the original start date of the occurrence.
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteEvent(eventId: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteEventWithHttpInfo(eventId = eventId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an event.
     * **Note:** To delete an instance of recurring event, use the master event id suffixed by the original start date of the occurrence.
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteEventWithHttpInfo(eventId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteEventRequestConfig(eventId = eventId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteEvent
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return RequestConfig
     */
    fun deleteEventRequestConfig(eventId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/crm/api/v1/events/{eventId}".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     *  Get informations about a calendar or a default calendar.
     * 
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return CalendarsCalendar
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCalendar(calendarId: kotlin.String, acceptLanguage: kotlin.String? = null) : CalendarsCalendar {
        val localVarResponse = getCalendarWithHttpInfo(calendarId = calendarId, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CalendarsCalendar
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     *  Get informations about a calendar or a default calendar.
     * 
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<CalendarsCalendar?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCalendarWithHttpInfo(calendarId: kotlin.String, acceptLanguage: kotlin.String?) : ApiResponse<CalendarsCalendar?> {
        val localVariableConfig = getCalendarRequestConfig(calendarId = calendarId, acceptLanguage = acceptLanguage)

        return request<Unit, CalendarsCalendar>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCalendar
     *
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun getCalendarRequestConfig(calendarId: kotlin.String, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/calendars/{calendarId}".replace("{"+"calendarId"+"}", "$calendarId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Return the detail of an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return EventsEvent
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvent(eventId: kotlin.String, acceptLanguage: kotlin.String? = null) : EventsEvent {
        val localVarResponse = getEventWithHttpInfo(eventId = eventId, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsEvent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Return the detail of an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<EventsEvent?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventWithHttpInfo(eventId: kotlin.String, acceptLanguage: kotlin.String?) : ApiResponse<EventsEvent?> {
        val localVariableConfig = getEventRequestConfig(eventId = eventId, acceptLanguage = acceptLanguage)

        return request<Unit, EventsEvent>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvent
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun getEventRequestConfig(eventId: kotlin.String, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/events/{eventId}".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get a recurring event instances.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return EventsGetEventInstancesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventInstances(eventId: kotlin.String, minTime: java.time.OffsetDateTime? = null, maxTime: java.time.OffsetDateTime? = null, pageToken: kotlin.String? = null, maxResults: kotlin.String? = null, acceptLanguage: kotlin.String? = null) : EventsGetEventInstancesResponse {
        val localVarResponse = getEventInstancesWithHttpInfo(eventId = eventId, minTime = minTime, maxTime = maxTime, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsGetEventInstancesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a recurring event instances.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<EventsGetEventInstancesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventInstancesWithHttpInfo(eventId: kotlin.String, minTime: java.time.OffsetDateTime?, maxTime: java.time.OffsetDateTime?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : ApiResponse<EventsGetEventInstancesResponse?> {
        val localVariableConfig = getEventInstancesRequestConfig(eventId = eventId, minTime = minTime, maxTime = maxTime, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        return request<Unit, EventsGetEventInstancesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventInstances
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun getEventInstancesRequestConfig(eventId: kotlin.String, minTime: java.time.OffsetDateTime?, maxTime: java.time.OffsetDateTime?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minTime != null) {
                    put("minTime", listOf(parseDateToQueryString(minTime)))
                }
                if (maxTime != null) {
                    put("maxTime", listOf(parseDateToQueryString(maxTime)))
                }
                if (pageToken != null) {
                    put("pageToken", listOf(pageToken.toString()))
                }
                if (maxResults != null) {
                    put("maxResults", listOf(maxResults.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/events/{eventId}/instances".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the internal notes list for an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param history Query all revisions or not. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return InternalNotesNoteList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEventInternalNoteList(eventId: kotlin.String, history: InternalNotesHistoryType? = null, acceptLanguage: kotlin.String? = null) : InternalNotesNoteList {
        val localVarResponse = getEventInternalNoteListWithHttpInfo(eventId = eventId, history = history, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesNoteList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get the internal notes list for an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param history Query all revisions or not. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<InternalNotesNoteList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventInternalNoteListWithHttpInfo(eventId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : ApiResponse<InternalNotesNoteList?> {
        val localVariableConfig = getEventInternalNoteListRequestConfig(eventId = eventId, history = history, acceptLanguage = acceptLanguage)

        return request<Unit, InternalNotesNoteList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEventInternalNoteList
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param history Query all revisions or not. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun getEventInternalNoteListRequestConfig(eventId: kotlin.String, history: InternalNotesHistoryType?, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (history != null) {
                    put("history", listOf(history.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/events/{eventId}/notes".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the list of available calendars.
     * 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return CalendarsListCalendarResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listCalendars(acceptLanguage: kotlin.String? = null) : CalendarsListCalendarResponse {
        val localVarResponse = listCalendarsWithHttpInfo(acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CalendarsListCalendarResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get the list of available calendars.
     * 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<CalendarsListCalendarResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listCalendarsWithHttpInfo(acceptLanguage: kotlin.String?) : ApiResponse<CalendarsListCalendarResponse?> {
        val localVariableConfig = listCalendarsRequestConfig(acceptLanguage = acceptLanguage)

        return request<Unit, CalendarsListCalendarResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCalendars
     *
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun listCalendarsRequestConfig(acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/calendars",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List or search events.
     * 
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar. (optional)
     * @param ownerId Owner ID filter param. (optional)
     * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param singleEvents Expand recurring events into occurrences. When singleEvents is true, master recurrences are not returned in list. (optional)
     * @param isCompleted If true, include only completed events. If false, include only TODO event. If not set or null, include both. (optional)
     * @param orderBy Specify the order of the results. &#x60;startTime&#x60; may result in inconsistant sort when used without the &#x60;singleEvents&#x60; option. (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return EventsListEventResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listEvents(calendarId: kotlin.String? = null, ownerId: kotlin.String? = null, contactIds: kotlin.collections.List<kotlin.Int>? = null, minTime: java.time.OffsetDateTime? = null, maxTime: java.time.OffsetDateTime? = null, singleEvents: kotlin.Boolean? = null, isCompleted: kotlin.Boolean? = null, orderBy: EventsOrderByType? = null, pageToken: kotlin.String? = null, maxResults: kotlin.String? = null, acceptLanguage: kotlin.String? = null) : EventsListEventResponse {
        val localVarResponse = listEventsWithHttpInfo(calendarId = calendarId, ownerId = ownerId, contactIds = contactIds, minTime = minTime, maxTime = maxTime, singleEvents = singleEvents, isCompleted = isCompleted, orderBy = orderBy, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsListEventResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List or search events.
     * 
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar. (optional)
     * @param ownerId Owner ID filter param. (optional)
     * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param singleEvents Expand recurring events into occurrences. When singleEvents is true, master recurrences are not returned in list. (optional)
     * @param isCompleted If true, include only completed events. If false, include only TODO event. If not set or null, include both. (optional)
     * @param orderBy Specify the order of the results. &#x60;startTime&#x60; may result in inconsistant sort when used without the &#x60;singleEvents&#x60; option. (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<EventsListEventResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listEventsWithHttpInfo(calendarId: kotlin.String?, ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minTime: java.time.OffsetDateTime?, maxTime: java.time.OffsetDateTime?, singleEvents: kotlin.Boolean?, isCompleted: kotlin.Boolean?, orderBy: EventsOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : ApiResponse<EventsListEventResponse?> {
        val localVariableConfig = listEventsRequestConfig(calendarId = calendarId, ownerId = ownerId, contactIds = contactIds, minTime = minTime, maxTime = maxTime, singleEvents = singleEvents, isCompleted = isCompleted, orderBy = orderBy, pageToken = pageToken, maxResults = maxResults, acceptLanguage = acceptLanguage)

        return request<Unit, EventsListEventResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listEvents
     *
     * @param calendarId Calendar ID filter param. An id returned by listCalendars. The string &#x60;primary&#x60; for the current connected user primary (TODO) calendar. The string &#x60;completed&#x60; for the current connected user completed (DONE) calendar. (optional)
     * @param ownerId Owner ID filter param. (optional)
     * @param contactIds Contact ID filter param. Many ids can be passed to this argument separated by coma. Ex: &#39;?contactId&#x3D;1,2,3&#39;. Any of the given contacts will be returned in the result. (optional)
     * @param minTime Minimum (inclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param maxTime Maximum (exclusive) date and time of the event start time. As defined by date-time - RFC3339 (optional)
     * @param singleEvents Expand recurring events into occurrences. When singleEvents is true, master recurrences are not returned in list. (optional)
     * @param isCompleted If true, include only completed events. If false, include only TODO event. If not set or null, include both. (optional)
     * @param orderBy Specify the order of the results. &#x60;startTime&#x60; may result in inconsistant sort when used without the &#x60;singleEvents&#x60; option. (optional)
     * @param pageToken Token to specify which page to fetch. (optional)
     * @param maxResults Maximum number of records for one result page.  If the query return more records, nextPageToken will be specified in the result to get the records of the next page. Defaults to 250 records. Can never be more than 2500 records. (optional)
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun listEventsRequestConfig(calendarId: kotlin.String?, ownerId: kotlin.String?, contactIds: kotlin.collections.List<kotlin.Int>?, minTime: java.time.OffsetDateTime?, maxTime: java.time.OffsetDateTime?, singleEvents: kotlin.Boolean?, isCompleted: kotlin.Boolean?, orderBy: EventsOrderByType?, pageToken: kotlin.String?, maxResults: kotlin.String?, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (calendarId != null) {
                    put("calendarId", listOf(calendarId.toString()))
                }
                if (ownerId != null) {
                    put("ownerId", listOf(ownerId.toString()))
                }
                if (contactIds != null) {
                    put("contactIds", toMultiValue(contactIds.toList(), "multi"))
                }
                if (minTime != null) {
                    put("minTime", listOf(parseDateToQueryString(minTime)))
                }
                if (maxTime != null) {
                    put("maxTime", listOf(parseDateToQueryString(maxTime)))
                }
                if (singleEvents != null) {
                    put("singleEvents", listOf(singleEvents.toString()))
                }
                if (isCompleted != null) {
                    put("isCompleted", listOf(isCompleted.toString()))
                }
                if (orderBy != null) {
                    put("orderBy", listOf(orderBy.toString()))
                }
                if (pageToken != null) {
                    put("pageToken", listOf(pageToken.toString()))
                }
                if (maxResults != null) {
                    put("maxResults", listOf(maxResults.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crm/api/v1/events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Partially update an event.
     * **Note:** To update an instance of recurring event, use the master event id suffixed by the original start date of the occurrence.
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param eventsPatchEventPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return EventsPatchEventResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchEvent(eventId: kotlin.String, eventsPatchEventPayload: EventsPatchEventPayload, acceptLanguage: kotlin.String? = null) : EventsPatchEventResponse {
        val localVarResponse = patchEventWithHttpInfo(eventId = eventId, eventsPatchEventPayload = eventsPatchEventPayload, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsPatchEventResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Partially update an event.
     * **Note:** To update an instance of recurring event, use the master event id suffixed by the original start date of the occurrence.
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param eventsPatchEventPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<EventsPatchEventResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchEventWithHttpInfo(eventId: kotlin.String, eventsPatchEventPayload: EventsPatchEventPayload, acceptLanguage: kotlin.String?) : ApiResponse<EventsPatchEventResponse?> {
        val localVariableConfig = patchEventRequestConfig(eventId = eventId, eventsPatchEventPayload = eventsPatchEventPayload, acceptLanguage = acceptLanguage)

        return request<EventsPatchEventPayload, EventsPatchEventResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchEvent
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param eventsPatchEventPayload Event fields to update. The body of the patch request includes only the resource fields you want to modify. To delete a field, set it to null. Collections are always overridden if defined.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun patchEventRequestConfig(eventId: kotlin.String, eventsPatchEventPayload: EventsPatchEventPayload, acceptLanguage: kotlin.String?) : RequestConfig<EventsPatchEventPayload> {
        val localVariableBody = eventsPatchEventPayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/events/{eventId}".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add an internal note to and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param internalNotesPatchNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return InternalNotesPatchNoteResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchEventInternalNote(eventId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String? = null) : InternalNotesPatchNoteResponse {
        val localVarResponse = patchEventInternalNoteWithHttpInfo(eventId = eventId, noteId = noteId, internalNotesPatchNotePayload = internalNotesPatchNotePayload, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InternalNotesPatchNoteResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add an internal note to and event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param internalNotesPatchNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<InternalNotesPatchNoteResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchEventInternalNoteWithHttpInfo(eventId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : ApiResponse<InternalNotesPatchNoteResponse?> {
        val localVariableConfig = patchEventInternalNoteRequestConfig(eventId = eventId, noteId = noteId, internalNotesPatchNotePayload = internalNotesPatchNotePayload, acceptLanguage = acceptLanguage)

        return request<InternalNotesPatchNotePayload, InternalNotesPatchNoteResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchEventInternalNote
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param internalNotesPatchNotePayload 
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun patchEventInternalNoteRequestConfig(eventId: kotlin.String, noteId: kotlin.Int, internalNotesPatchNotePayload: InternalNotesPatchNotePayload, acceptLanguage: kotlin.String?) : RequestConfig<InternalNotesPatchNotePayload> {
        val localVariableBody = internalNotesPatchNotePayload
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/crm/api/v1/events/{eventId}/notes/{noteId}".replace("{"+"eventId"+"}", "$eventId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Restore an archived internal note for an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun restoreEventInternalNote(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String? = null) : kotlin.Any {
        val localVarResponse = restoreEventInternalNoteWithHttpInfo(eventId = eventId, noteId = noteId, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Restore an archived internal note for an event.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun restoreEventInternalNoteWithHttpInfo(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = restoreEventInternalNoteRequestConfig(eventId = eventId, noteId = noteId, acceptLanguage = acceptLanguage)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation restoreEventInternalNote
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @param noteId Note unique identifier.
     * @param acceptLanguage Specify preferred language for returned data. Format is https://tools.ietf.org/html/rfc3282 (optional)
     * @return RequestConfig
     */
    fun restoreEventInternalNoteRequestConfig(eventId: kotlin.String, noteId: kotlin.Int, acceptLanguage: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/events/{eventId}/notes/{noteId}/restore".replace("{"+"eventId"+"}", "$eventId").replace("{"+"noteId"+"}", "$noteId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Transfer an event to the completed/done calendar.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return EventsTransferToCompletedResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun transferEventToCompleted(eventId: kotlin.String) : EventsTransferToCompletedResponse {
        val localVarResponse = transferEventToCompletedWithHttpInfo(eventId = eventId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EventsTransferToCompletedResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Transfer an event to the completed/done calendar.
     * 
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return ApiResponse<EventsTransferToCompletedResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun transferEventToCompletedWithHttpInfo(eventId: kotlin.String) : ApiResponse<EventsTransferToCompletedResponse?> {
        val localVariableConfig = transferEventToCompletedRequestConfig(eventId = eventId)

        return request<Unit, EventsTransferToCompletedResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation transferEventToCompleted
     *
     * @param eventId Event unique identifier. For recurrence occurrence/exception, eventId is suffixed with the original start date of the occurrence. For example 999_20180101.
     * @return RequestConfig
     */
    fun transferEventToCompletedRequestConfig(eventId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/crm/api/v1/events/{eventId}/transferToCompleted".replace("{"+"eventId"+"}", "$eventId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
