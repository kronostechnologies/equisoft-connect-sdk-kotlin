/**
* Equisoft /connect API
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: latest
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package com.equisoft.connect.sdk.models

import com.equisoft.connect.sdk.models.AccessRights
import com.equisoft.connect.sdk.models.DateOrDateTime
import com.equisoft.connect.sdk.models.FieldValue

import com.squareup.moshi.Json

/**
 * 
 * @param id Unique numerical identifier.
 * @param subject Subject/Title of the Event.
 * @param start 
 * @param end 
 * @param allDay Indicate if the event is an all-day event or a timed event.
 * @param isCompleted Is the event part of a completed/done calendar.
 * @param type Event type (CALL, LETTER, MEETING, VACATION, FILE, NOTE)
 * @param calendarId ID of the calendar owning this Event. If owned by many users, calendarId will be - The primary ( or completed depending on state) calendar ID of the connected user if the user is the he is one of the owners. - Any primary ( or completed depending on state) completed calendar ID of one of the owners.
 * @param accessRights 
 * @param initialDate Date the Event was initially scheduled. As defined by full-date - RFC3339
 * @param description Public description of the Event.
 * @param internalNotes Internal notes on the Event. Not synced on remote sources.
 * @param location Location of the event in free-text form.
 * @param category 
 * @param subCategory 
 * @param recurrenceRule The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
 * @param recurringEventId For an instance of recurring event, ID of the master event.
 * @param originalStartDate For an instance of recurring event, original start date of the event according to the recurrence rule.
 * @param priority Importance/Priority of an event or task. 5 is the most important.
 * @param visibility Confidentiality level of the Event (private or not). [NORMAL, PRIVATE]
 * @param creationTime Creation time. As defined by date-time - RFC3339
 * @param updateTime Date time of last modification. As defined by date-time - RFC3339
 * @param color hex color of this event background
 * @param textColor hex text color of this event
 * @param contactIds IDs of the contacts linked to this Event
 */

data class EventsEvent (
    /* Unique numerical identifier. */
    @Json(name = "id")
    val id: kotlin.String,
    /* Subject/Title of the Event. */
    @Json(name = "subject")
    val subject: kotlin.String,
    @Json(name = "start")
    val start: DateOrDateTime,
    @Json(name = "end")
    val end: DateOrDateTime,
    /* Indicate if the event is an all-day event or a timed event. */
    @Json(name = "allDay")
    val allDay: kotlin.Boolean,
    /* Is the event part of a completed/done calendar. */
    @Json(name = "isCompleted")
    val isCompleted: kotlin.Boolean,
    /* Event type (CALL, LETTER, MEETING, VACATION, FILE, NOTE) */
    @Json(name = "type")
    val type: kotlin.String,
    /* ID of the calendar owning this Event. If owned by many users, calendarId will be - The primary ( or completed depending on state) calendar ID of the connected user if the user is the he is one of the owners. - Any primary ( or completed depending on state) completed calendar ID of one of the owners. */
    @Json(name = "calendarId")
    val calendarId: kotlin.Int,
    @Json(name = "accessRights")
    val accessRights: AccessRights,
    /* Date the Event was initially scheduled. As defined by full-date - RFC3339 */
    @Json(name = "initialDate")
    val initialDate: kotlin.String? = null,
    /* Public description of the Event. */
    @Json(name = "description")
    val description: kotlin.String? = null,
    /* Internal notes on the Event. Not synced on remote sources. */
    @Json(name = "internalNotes")
    val internalNotes: kotlin.String? = null,
    /* Location of the event in free-text form. */
    @Json(name = "location")
    val location: kotlin.String? = null,
    @Json(name = "category")
    val category: FieldValue? = null,
    @Json(name = "subCategory")
    val subCategory: FieldValue? = null,
    /* The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3). */
    @Json(name = "recurrenceRule")
    val recurrenceRule: kotlin.String? = null,
    /* For an instance of recurring event, ID of the master event. */
    @Json(name = "recurringEventId")
    val recurringEventId: kotlin.String? = null,
    /* For an instance of recurring event, original start date of the event according to the recurrence rule. */
    @Json(name = "originalStartDate")
    val originalStartDate: kotlin.String? = null,
    /* Importance/Priority of an event or task. 5 is the most important. */
    @Json(name = "priority")
    val priority: kotlin.Int? = null,
    /* Confidentiality level of the Event (private or not). [NORMAL, PRIVATE] */
    @Json(name = "visibility")
    val visibility: kotlin.String? = null,
    /* Creation time. As defined by date-time - RFC3339 */
    @Json(name = "creationTime")
    val creationTime: java.time.OffsetDateTime? = null,
    /* Date time of last modification. As defined by date-time - RFC3339 */
    @Json(name = "updateTime")
    val updateTime: java.time.OffsetDateTime? = null,
    /* hex color of this event background */
    @Json(name = "color")
    val color: kotlin.String? = null,
    /* hex text color of this event */
    @Json(name = "textColor")
    val textColor: kotlin.String? = null,
    /* IDs of the contacts linked to this Event */
    @Json(name = "contactIds")
    val contactIds: kotlin.collections.List<kotlin.Int>? = null
)

